// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type FileCreateInput struct {
	Path     string `json:"path"`
	Filename string `json:"filename"`
	Mimetype string `json:"mimetype"`
	Encoding string `json:"encoding"`
	Size     int    `json:"size"`
}

type FileUpdateInput struct {
	Path     *string `json:"path"`
	Filename *string `json:"filename"`
	Mimetype *string `json:"mimetype"`
	Encoding *string `json:"encoding"`
	Size     *int    `json:"size"`
}

type FileWhereInput struct {
	ID                    *string          `json:"id"`
	IDNot                 *string          `json:"id_not"`
	IDIn                  []string         `json:"id_in"`
	IDNotIn               []string         `json:"id_not_in"`
	Path                  *string          `json:"path"`
	PathNot               *string          `json:"path_not"`
	PathIn                []string         `json:"path_in"`
	PathNotIn             []string         `json:"path_not_in"`
	PathContains          *string          `json:"path_contains"`
	PathNotContains       *string          `json:"path_not_contains"`
	PathStartsWith        *string          `json:"path_starts_with"`
	PathNotStartsWith     *string          `json:"path_not_starts_with"`
	PathEndsWith          *string          `json:"path_ends_with"`
	PathNotEndsWith       *string          `json:"path_not_ends_with"`
	Filename              *string          `json:"filename"`
	FilenameNot           *string          `json:"filename_not"`
	FilenameIn            []string         `json:"filename_in"`
	FilenameNotIn         []string         `json:"filename_not_in"`
	FilenameContains      *string          `json:"filename_contains"`
	FilenameNotContains   *string          `json:"filename_not_contains"`
	FilenameStartsWith    *string          `json:"filename_starts_with"`
	FilenameNotStartsWith *string          `json:"filename_not_starts_with"`
	FilenameEndsWith      *string          `json:"filename_ends_with"`
	FilenameNotEndsWith   *string          `json:"filename_not_ends_with"`
	Mimetype              *string          `json:"mimetype"`
	MimetypeNot           *string          `json:"mimetype_not"`
	MimetypeIn            []string         `json:"mimetype_in"`
	MimetypeNotIn         []string         `json:"mimetype_not_in"`
	MimetypeContains      *string          `json:"mimetype_contains"`
	MimetypeNotContains   *string          `json:"mimetype_not_contains"`
	MimetypeStartsWith    *string          `json:"mimetype_starts_with"`
	MimetypeNotStartsWith *string          `json:"mimetype_not_starts_with"`
	MimetypeEndsWith      *string          `json:"mimetype_ends_with"`
	MimetypeNotEndsWith   *string          `json:"mimetype_not_ends_with"`
	Encoding              *string          `json:"encoding"`
	EncodingNot           *string          `json:"encoding_not"`
	EncodingIn            []string         `json:"encoding_in"`
	EncodingNotIn         []string         `json:"encoding_not_in"`
	EncodingContains      *string          `json:"encoding_contains"`
	EncodingNotContains   *string          `json:"encoding_not_contains"`
	EncodingStartsWith    *string          `json:"encoding_starts_with"`
	EncodingNotStartsWith *string          `json:"encoding_not_starts_with"`
	EncodingEndsWith      *string          `json:"encoding_ends_with"`
	EncodingNotEndsWith   *string          `json:"encoding_not_ends_with"`
	Size                  *int             `json:"size"`
	SizeNot               *int             `json:"size_not"`
	SizeIn                []int            `json:"size_in"`
	SizeNotIn             []int            `json:"size_not_in"`
	SizeLt                *int             `json:"size_lt"`
	SizeLte               *int             `json:"size_lte"`
	SizeGt                *int             `json:"size_gt"`
	SizeGte               *int             `json:"size_gte"`
	And                   []FileWhereInput `json:"AND"`
	Or                    []FileWhereInput `json:"OR"`
	Not                   []FileWhereInput `json:"NOT"`
}

type FileWhereUniqueInput struct {
	ID *string `json:"id"`
}

type RoleCreateInput struct {
	Name  string `json:"name"`
	Email string `json:"email"`
}

type RoleUpdateInput struct {
	Name  *string `json:"name"`
	Email *string `json:"email"`
}

type RoleWhereInput struct {
	ID                *string          `json:"id"`
	IDNot             *string          `json:"id_not"`
	IDIn              []string         `json:"id_in"`
	IDNotIn           []string         `json:"id_not_in"`
	Name              *string          `json:"name"`
	NameNot           *string          `json:"name_not"`
	NameIn            []string         `json:"name_in"`
	NameNotIn         []string         `json:"name_not_in"`
	NameContains      *string          `json:"name_contains"`
	NameNotContains   *string          `json:"name_not_contains"`
	NameStartsWith    *string          `json:"name_starts_with"`
	NameNotStartsWith *string          `json:"name_not_starts_with"`
	NameEndsWith      *string          `json:"name_ends_with"`
	NameNotEndsWith   *string          `json:"name_not_ends_with"`
	And               []RoleWhereInput `json:"AND"`
	Or                []RoleWhereInput `json:"OR"`
	Not               []RoleWhereInput `json:"NOT"`
}

type RoleWhereUniqueInput struct {
	ID *string `json:"id"`
}

type UserCreateInput struct {
	Name     string `json:"name"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

type UserUpdateInput struct {
	Name  *string `json:"name"`
	Email *string `json:"email"`
}

type UserWhereInput struct {
	Name *string `json:"name"`
}

type UserWhereUniqueInput struct {
	ID *string `json:"id"`
}

type FileOrderByInput string

const (
	FileOrderByInputIDAsc         FileOrderByInput = "id_ASC"
	FileOrderByInputIDDesc        FileOrderByInput = "id_DESC"
	FileOrderByInputPathAsc       FileOrderByInput = "path_ASC"
	FileOrderByInputPathDesc      FileOrderByInput = "path_DESC"
	FileOrderByInputFilenameAsc   FileOrderByInput = "filename_ASC"
	FileOrderByInputFilenameDesc  FileOrderByInput = "filename_DESC"
	FileOrderByInputMimetypeAsc   FileOrderByInput = "mimetype_ASC"
	FileOrderByInputMimetypeDesc  FileOrderByInput = "mimetype_DESC"
	FileOrderByInputEncodingAsc   FileOrderByInput = "encoding_ASC"
	FileOrderByInputEncodingDesc  FileOrderByInput = "encoding_DESC"
	FileOrderByInputSizeAsc       FileOrderByInput = "size_ASC"
	FileOrderByInputSizeDesc      FileOrderByInput = "size_DESC"
	FileOrderByInputCreatedAtAsc  FileOrderByInput = "createdAt_ASC"
	FileOrderByInputCreatedAtDesc FileOrderByInput = "createdAt_DESC"
	FileOrderByInputUpdatedAtAsc  FileOrderByInput = "updatedAt_ASC"
	FileOrderByInputUpdatedAtDesc FileOrderByInput = "updatedAt_DESC"
)

var AllFileOrderByInput = []FileOrderByInput{
	FileOrderByInputIDAsc,
	FileOrderByInputIDDesc,
	FileOrderByInputPathAsc,
	FileOrderByInputPathDesc,
	FileOrderByInputFilenameAsc,
	FileOrderByInputFilenameDesc,
	FileOrderByInputMimetypeAsc,
	FileOrderByInputMimetypeDesc,
	FileOrderByInputEncodingAsc,
	FileOrderByInputEncodingDesc,
	FileOrderByInputSizeAsc,
	FileOrderByInputSizeDesc,
	FileOrderByInputCreatedAtAsc,
	FileOrderByInputCreatedAtDesc,
	FileOrderByInputUpdatedAtAsc,
	FileOrderByInputUpdatedAtDesc,
}

func (e FileOrderByInput) IsValid() bool {
	switch e {
	case FileOrderByInputIDAsc, FileOrderByInputIDDesc, FileOrderByInputPathAsc, FileOrderByInputPathDesc, FileOrderByInputFilenameAsc, FileOrderByInputFilenameDesc, FileOrderByInputMimetypeAsc, FileOrderByInputMimetypeDesc, FileOrderByInputEncodingAsc, FileOrderByInputEncodingDesc, FileOrderByInputSizeAsc, FileOrderByInputSizeDesc, FileOrderByInputCreatedAtAsc, FileOrderByInputCreatedAtDesc, FileOrderByInputUpdatedAtAsc, FileOrderByInputUpdatedAtDesc:
		return true
	}
	return false
}

func (e FileOrderByInput) String() string {
	return string(e)
}

func (e *FileOrderByInput) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileOrderByInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileOrderByInput", str)
	}
	return nil
}

func (e FileOrderByInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RoleOrderByInput string

const (
	RoleOrderByInputIDAsc    RoleOrderByInput = "id_ASC"
	RoleOrderByInputIDDesc   RoleOrderByInput = "id_DESC"
	RoleOrderByInputNameAsc  RoleOrderByInput = "name_ASC"
	RoleOrderByInputNameDesc RoleOrderByInput = "name_DESC"
)

var AllRoleOrderByInput = []RoleOrderByInput{
	RoleOrderByInputIDAsc,
	RoleOrderByInputIDDesc,
	RoleOrderByInputNameAsc,
	RoleOrderByInputNameDesc,
}

func (e RoleOrderByInput) IsValid() bool {
	switch e {
	case RoleOrderByInputIDAsc, RoleOrderByInputIDDesc, RoleOrderByInputNameAsc, RoleOrderByInputNameDesc:
		return true
	}
	return false
}

func (e RoleOrderByInput) String() string {
	return string(e)
}

func (e *RoleOrderByInput) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleOrderByInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleOrderByInput", str)
	}
	return nil
}

func (e RoleOrderByInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrderByInput string

const (
	UserOrderByInputIDAsc     UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc    UserOrderByInput = "id_DESC"
	UserOrderByInputNameAsc   UserOrderByInput = "name_ASC"
	UserOrderByInputNameDesc  UserOrderByInput = "name_DESC"
	UserOrderByInputEmailAsc  UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc UserOrderByInput = "email_DESC"
)

var AllUserOrderByInput = []UserOrderByInput{
	UserOrderByInputIDAsc,
	UserOrderByInputIDDesc,
	UserOrderByInputNameAsc,
	UserOrderByInputNameDesc,
	UserOrderByInputEmailAsc,
	UserOrderByInputEmailDesc,
}

func (e UserOrderByInput) IsValid() bool {
	switch e {
	case UserOrderByInputIDAsc, UserOrderByInputIDDesc, UserOrderByInputNameAsc, UserOrderByInputNameDesc, UserOrderByInputEmailAsc, UserOrderByInputEmailDesc:
		return true
	}
	return false
}

func (e UserOrderByInput) String() string {
	return string(e)
}

func (e *UserOrderByInput) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderByInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderByInput", str)
	}
	return nil
}

func (e UserOrderByInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
